# Generated by apidoc - http://www.apidoc.me
# Service version: 0.0.11
# apidoc:0.11.17 http://www.apidoc.me/flow/catalog/0.0.11/ruby_client

require 'cgi'
require 'net/http'
require 'net/https'
require 'uri'
require 'base64'

require 'date'
require 'rubygems'
require 'json'
require 'bigdecimal'

module Io
  module Flow
    module Catalog
      module V0

        class Client

          module Constants

            BASE_URL = 'https://catalog.api.flow.io' unless defined?(Constants::BASE_URL)
            NAMESPACE = 'io.flow.catalog.v0' unless defined?(Constants::NAMESPACE)
            USER_AGENT = 'apidoc:0.11.17 http://www.apidoc.me/flow/catalog/0.0.11/ruby_client' unless defined?(Constants::USER_AGENT)
            VERSION = '0.0.11' unless defined?(Constants::VERSION)
            VERSION_MAJOR = 0 unless defined?(VERSION_MAJOR)

          end

          attr_reader :url

          def initialize(url, opts={})
            @url = HttpClient::Preconditions.assert_class('url', url, String)
            @authorization = HttpClient::Preconditions.assert_class_or_nil('authorization', opts.delete(:authorization), HttpClient::Authorization)
            @default_headers = HttpClient::Preconditions.assert_class('default_headers', opts.delete(:default_headers) || {}, Hash)
            HttpClient::Preconditions.assert_empty_opts(opts)
            HttpClient::Preconditions.check_state(url.match(/http.+/i), "URL[%s] must start with http" % url)
          end

          # Creates an instance of the client using the base url specified in the API spec.
          def Client.at_base_url(opts={})
            Client.new(Constants::BASE_URL, opts)
          end

          def request(path=nil)
            HttpClient::Preconditions.assert_class_or_nil('path', path, String)
            request = HttpClient::Request.new(URI.parse(@url + path.to_s)).with_header('User-Agent', Constants::USER_AGENT).with_header('X-Apidoc-Version', Constants::VERSION).with_header('X-Apidoc-Version-Major', Constants::VERSION_MAJOR)

            @default_headers.each do |key, value|
              request = request.with_header(key, value)
            end

            if @authorization
              request = request.with_auth(@authorization)
            end

            request
          end

          def catalogs
            @catalogs ||= ::Io::Flow::Catalog::V0::Clients::Catalogs.new(self)
          end

          def catalog_items
            @catalog_items ||= ::Io::Flow::Catalog::V0::Clients::CatalogItems.new(self)
          end

          def healthchecks
            @healthchecks ||= ::Io::Flow::Catalog::V0::Clients::Healthchecks.new(self)
          end

          def views
            @views ||= ::Io::Flow::Catalog::V0::Clients::Views.new(self)
          end

          def view_items
            @view_items ||= ::Io::Flow::Catalog::V0::Clients::ViewItems.new(self)
          end
        end

        module Clients

          class Catalogs

            def initialize(client)
              @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::Catalog::V0::Client)
            end

            # Returns information about a specific catalog.
            def get_catalog(organization)
              HttpClient::Preconditions.assert_class('organization', organization, String)
              r = @client.request("/#{CGI.escape(organization)}/catalog").get
              ::Io::Flow::Catalog::V0::Models::Catalog.new(r)
            end

          end

          class CatalogItems

            def initialize(client)
              @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::Catalog::V0::Client)
            end

            # Provides visibility into recent changes of each object, including deletion
            def get_versions(organization, incoming={})
              HttpClient::Preconditions.assert_class('organization', organization, String)
              opts = HttpClient::Helper.symbolize_keys(incoming)
              query = {
                :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
                :number => (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, Array).map { |v| HttpClient::Preconditions.assert_class('number', v, String) }),
                :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
                :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
                :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
              }.delete_if { |k, v| v.nil? }
              r = @client.request("/#{CGI.escape(organization)}/catalog/items/versions").with_query(query).get
              r.map { |x| ::Io::Flow::Catalog::V0::Models::ItemVersion.new(x) }
            end

            # Search items. Always paginated.
            def get(organization, incoming={})
              HttpClient::Preconditions.assert_class('organization', organization, String)
              opts = HttpClient::Helper.symbolize_keys(incoming)
              query = {
                :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
                :number => (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, Array).map { |v| HttpClient::Preconditions.assert_class('number', v, String) }),
                :query => (x = opts.delete(:query); x.nil? ? nil : HttpClient::Preconditions.assert_class('query', x, String)),
                :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
                :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
                :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
              }.delete_if { |k, v| v.nil? }
              r = @client.request("/#{CGI.escape(organization)}/catalog/items").with_query(query).get
              r.map { |x| ::Io::Flow::Catalog::V0::Models::Item.new(x) }
            end

            # Returns information about a specific item.
            def get_by_id(organization, id)
              HttpClient::Preconditions.assert_class('organization', organization, String)
              HttpClient::Preconditions.assert_class('id', id, String)
              r = @client.request("/#{CGI.escape(organization)}/catalog/items/#{CGI.escape(id)}").get
              ::Io::Flow::Catalog::V0::Models::Item.new(r)
            end

            # Add catalog item(s)
            def post(organization, item_form)
              HttpClient::Preconditions.assert_class('organization', organization, String)
              HttpClient::Preconditions.assert_class('item_form', item_form, ::Io::Flow::Catalog::V0::Models::ItemForm)
              r = @client.request("/#{CGI.escape(organization)}/catalog/items").with_json(item_form.to_json).post
              ::Io::Flow::Catalog::V0::Models::Item.new(r)
            end

            # Update item with the specified id.
            def put_by_id(organization, id, item_form)
              HttpClient::Preconditions.assert_class('organization', organization, String)
              HttpClient::Preconditions.assert_class('id', id, String)
              HttpClient::Preconditions.assert_class('item_form', item_form, ::Io::Flow::Catalog::V0::Models::ItemForm)
              r = @client.request("/#{CGI.escape(organization)}/catalog/items/#{CGI.escape(id)}").with_json(item_form.to_json).put
              ::Io::Flow::Catalog::V0::Models::Item.new(r)
            end

            # Delete the item with this id
            def delete_by_id(organization, id)
              HttpClient::Preconditions.assert_class('organization', organization, String)
              HttpClient::Preconditions.assert_class('id', id, String)
              r = @client.request("/#{CGI.escape(organization)}/catalog/items/#{CGI.escape(id)}").delete
              nil
            end

          end

          class Healthchecks

            def initialize(client)
              @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::Catalog::V0::Client)
            end

            def get_healthcheck
              r = @client.request("/_internal_/healthcheck").get
              ::Io::Flow::Common::V0::Models::Healthcheck.new(r)
            end

          end

          class Views

            def initialize(client)
              @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::Catalog::V0::Client)
            end

            # Provides visibility into recent changes of each object, including deletion
            def get_versions(organization, incoming={})
              HttpClient::Preconditions.assert_class('organization', organization, String)
              opts = HttpClient::Helper.symbolize_keys(incoming)
              query = {
                :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
                :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
                :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
                :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
              }.delete_if { |k, v| v.nil? }
              r = @client.request("/#{CGI.escape(organization)}/catalog/views/versions").with_query(query).get
              r.map { |x| ::Io::Flow::Catalog::V0::Models::ViewVersion.new(x) }
            end

            # Search views. Always paginated.
            def get(organization, incoming={})
              HttpClient::Preconditions.assert_class('organization', organization, String)
              opts = HttpClient::Helper.symbolize_keys(incoming)
              query = {
                :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
                :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
                :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
                :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
              }.delete_if { |k, v| v.nil? }
              r = @client.request("/#{CGI.escape(organization)}/catalog/views").with_query(query).get
              r.map { |x| ::Io::Flow::Catalog::V0::Models::View.new(x) }
            end

            # Returns information about a specific view.
            def get_by_id(organization, id)
              HttpClient::Preconditions.assert_class('organization', organization, String)
              HttpClient::Preconditions.assert_class('id', id, String)
              r = @client.request("/#{CGI.escape(organization)}/catalog/views/#{CGI.escape(id)}").get
              ::Io::Flow::Catalog::V0::Models::View.new(r)
            end

            # Add view
            def post(organization, view_form)
              HttpClient::Preconditions.assert_class('organization', organization, String)
              HttpClient::Preconditions.assert_class('view_form', view_form, ::Io::Flow::Catalog::V0::Models::ViewForm)
              r = @client.request("/#{CGI.escape(organization)}/catalog/views").with_json(view_form.to_json).post
              ::Io::Flow::Catalog::V0::Models::View.new(r)
            end

            # Update view with the specified id.
            def put_by_id(organization, id, view_form)
              HttpClient::Preconditions.assert_class('organization', organization, String)
              HttpClient::Preconditions.assert_class('id', id, String)
              HttpClient::Preconditions.assert_class('view_form', view_form, ::Io::Flow::Catalog::V0::Models::ViewForm)
              r = @client.request("/#{CGI.escape(organization)}/catalog/views/#{CGI.escape(id)}").with_json(view_form.to_json).put
              ::Io::Flow::Catalog::V0::Models::View.new(r)
            end

            # Delete the view with this id
            def delete_by_id(organization, id)
              HttpClient::Preconditions.assert_class('organization', organization, String)
              HttpClient::Preconditions.assert_class('id', id, String)
              r = @client.request("/#{CGI.escape(organization)}/catalog/views/#{CGI.escape(id)}").delete
              nil
            end

            # Returns information about a specific view's settings.
            def get_settings_by_id(organization, id)
              HttpClient::Preconditions.assert_class('organization', organization, String)
              HttpClient::Preconditions.assert_class('id', id, String)
              r = @client.request("/#{CGI.escape(organization)}/catalog/views/#{CGI.escape(id)}/settings").get
              ::Io::Flow::Catalog::V0::Models::ViewSettings.new(r)
            end

            # Update view settings for the specified view.
            def put_settings_by_id(organization, id, view_settings_form)
              HttpClient::Preconditions.assert_class('organization', organization, String)
              HttpClient::Preconditions.assert_class('id', id, String)
              HttpClient::Preconditions.assert_class('view_settings_form', view_settings_form, ::Io::Flow::Catalog::V0::Models::ViewSettingsForm)
              r = @client.request("/#{CGI.escape(organization)}/catalog/views/#{CGI.escape(id)}/settings").with_json(view_settings_form.to_json).put
              ::Io::Flow::Catalog::V0::Models::ViewSettings.new(r)
            end

          end

          class ViewItems

            def initialize(client)
              @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::Catalog::V0::Client)
            end

            # Provides visibility into recent changes of each object, including deletion
            def get_versions(organization, view, incoming={})
              HttpClient::Preconditions.assert_class('organization', organization, String)
              HttpClient::Preconditions.assert_class('view', view, String)
              opts = HttpClient::Helper.symbolize_keys(incoming)
              query = {
                :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
                :number => (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, Array).map { |v| HttpClient::Preconditions.assert_class('number', v, String) }),
                :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
                :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
                :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
              }.delete_if { |k, v| v.nil? }
              r = @client.request("/#{CGI.escape(organization)}/catalog/views/#{CGI.escape(view)}/items/versions").with_query(query).get
              r.map { |x| ::Io::Flow::Catalog::V0::Models::ViewVersion.new(x) }
            end

            # Search view items. Always paginated.
            def get(organization, view, incoming={})
              HttpClient::Preconditions.assert_class('organization', organization, String)
              HttpClient::Preconditions.assert_class('view', view, String)
              opts = HttpClient::Helper.symbolize_keys(incoming)
              query = {
                :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
                :number => (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, Array).map { |v| HttpClient::Preconditions.assert_class('number', v, String) }),
                :query => (x = opts.delete(:query); x.nil? ? nil : HttpClient::Preconditions.assert_class('query', x, String)),
                :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
                :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
                :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
              }.delete_if { |k, v| v.nil? }
              r = @client.request("/#{CGI.escape(organization)}/catalog/views/#{CGI.escape(view)}/items").with_query(query).get
              r.map { |x| ::Io::Flow::Catalog::V0::Models::Item.new(x) }
            end

            # Returns information about specific view items.
            def get_by_id(organization, view, id)
              HttpClient::Preconditions.assert_class('organization', organization, String)
              HttpClient::Preconditions.assert_class('view', view, String)
              HttpClient::Preconditions.assert_class('id', id, String)
              r = @client.request("/#{CGI.escape(organization)}/catalog/views/#{CGI.escape(view)}/items/#{CGI.escape(id)}").get
              ::Io::Flow::Catalog::V0::Models::Item.new(r)
            end

            # Add view item
            def post(organization, view, item_form)
              HttpClient::Preconditions.assert_class('organization', organization, String)
              HttpClient::Preconditions.assert_class('view', view, String)
              HttpClient::Preconditions.assert_class('item_form', item_form, ::Io::Flow::Catalog::V0::Models::ItemForm)
              r = @client.request("/#{CGI.escape(organization)}/catalog/views/#{CGI.escape(view)}/items").with_json(item_form.to_json).post
              ::Io::Flow::Catalog::V0::Models::View.new(r)
            end

            # Update view item with the specified id.
            def put_by_id(organization, view, id, item_form)
              HttpClient::Preconditions.assert_class('organization', organization, String)
              HttpClient::Preconditions.assert_class('view', view, String)
              HttpClient::Preconditions.assert_class('id', id, String)
              HttpClient::Preconditions.assert_class('item_form', item_form, ::Io::Flow::Catalog::V0::Models::ItemForm)
              r = @client.request("/#{CGI.escape(organization)}/catalog/views/#{CGI.escape(view)}/items/#{CGI.escape(id)}").with_json(item_form.to_json).put
              ::Io::Flow::Catalog::V0::Models::Item.new(r)
            end

            # Delete the view item with this id
            def delete_by_id(organization, view, id)
              HttpClient::Preconditions.assert_class('organization', organization, String)
              HttpClient::Preconditions.assert_class('view', view, String)
              HttpClient::Preconditions.assert_class('id', id, String)
              r = @client.request("/#{CGI.escape(organization)}/catalog/views/#{CGI.escape(view)}/items/#{CGI.escape(id)}").delete
              nil
            end

          end

        end

        module Models

          class Event

            module Types
              ITEM_CREATED = 'item_created' unless defined?(ITEM_CREATED)
              ITEM_UPDATED = 'item_updated' unless defined?(ITEM_UPDATED)
              ITEM_DELETED = 'item_deleted' unless defined?(ITEM_DELETED)
            end

            def initialize(incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              HttpClient::Preconditions.require_keys(opts, [:name], 'Event')
              @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            end

            def to_hash
              subtype_to_hash.merge(:discriminator => @name)
            end

            def Event.from_json(hash)
              HttpClient::Preconditions.assert_class('hash', hash, Hash)
              case HttpClient::Helper.symbolize_keys(hash)[:discriminator]
                when Types::ITEM_CREATED; ItemCreated.new(hash)
                when Types::ITEM_UPDATED; ItemUpdated.new(hash)
                when Types::ITEM_DELETED; ItemDeleted.new(hash)
                else EventUndefinedType.new(:name => union_type_name)
              end
            end

          end

          class EventUndefinedType < Event

            attr_reader :name

            def initialize(incoming={})
              super(:name => 'undefined_type')
              opts = HttpClient::Helper.symbolize_keys(incoming)
              @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            end

            def subtype_to_hash
              raise 'Unable to serialize undefined type to json'
            end

            def copy(incoming={})
              raise 'Operation not supported for undefined type'
            end

            def to_hash
              raise 'Operation not supported for undefined type'
            end

          end

          class UpdatePolicy

            attr_reader :value

            def initialize(value)
              @value = HttpClient::Preconditions.assert_class('value', value, String)
            end

            # Returns the instance of UpdatePolicy for this value, creating a new instance for an unknown value
            def UpdatePolicy.apply(value)
              if value.instance_of?(UpdatePolicy)
                value
              else
                HttpClient::Preconditions.assert_class_or_nil('value', value, String)
                value.nil? ? nil : (from_string(value) || UpdatePolicy.new(value))
              end
            end

            # Returns the instance of UpdatePolicy for this value, or nil if not found
            def UpdatePolicy.from_string(value)
              HttpClient::Preconditions.assert_class('value', value, String)
              UpdatePolicy.ALL.find { |v| v.value == value }
            end

            def UpdatePolicy.ALL
              @@all ||= [UpdatePolicy.auto, UpdatePolicy.queue, UpdatePolicy.discard]
            end

            def UpdatePolicy.auto
              @@_auto ||= UpdatePolicy.new('auto')
            end

            # Queue item update for approval.
            def UpdatePolicy.queue
              @@_queue ||= UpdatePolicy.new('queue')
            end

            def UpdatePolicy.discard
              @@_discard ||= UpdatePolicy.new('discard')
            end

            def to_hash
              value
            end

          end

          class Attribute

            attr_reader :key, :value

            def initialize(incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              HttpClient::Preconditions.require_keys(opts, [:key, :value], 'Attribute')
              @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
              @value = HttpClient::Preconditions.assert_class('value', opts.delete(:value), String)
            end

            def to_json
              JSON.dump(to_hash)
            end

            def copy(incoming={})
              Attribute.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
            end

            def to_hash
              {
                :key => key,
                :value => value
              }
            end

          end

          class Catalog

            attr_reader :id

            def initialize(incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              HttpClient::Preconditions.require_keys(opts, [:id], 'Catalog')
              @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            end

            def to_json
              JSON.dump(to_hash)
            end

            def copy(incoming={})
              Catalog.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
            end

            def to_hash
              {
                :id => id
              }
            end

          end

          class CatalogForm

            attr_reader :id

            def initialize(incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              HttpClient::Preconditions.require_keys(opts, [:id], 'CatalogForm')
              @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            end

            def to_json
              JSON.dump(to_hash)
            end

            def copy(incoming={})
              CatalogForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
            end

            def to_hash
              {
                :id => id
              }
            end

          end

          class CatalogItem

            attr_reader :id, :catalog, :data

            def initialize(incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              HttpClient::Preconditions.require_keys(opts, [:id, :catalog, :data], 'CatalogItem')
              @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
              @catalog = (x = opts.delete(:catalog); x.is_a?(::Io::Flow::Catalog::V0::Models::Catalog) ? x : ::Io::Flow::Catalog::V0::Models::Catalog.new(x))
              @data = (x = opts.delete(:data); x.is_a?(::Io::Flow::Catalog::V0::Models::Item) ? x : ::Io::Flow::Catalog::V0::Models::Item.new(x))
            end

            def to_json
              JSON.dump(to_hash)
            end

            def copy(incoming={})
              CatalogItem.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
            end

            def to_hash
              {
                :id => id,
                :catalog => catalog.to_hash,
                :data => data.to_hash
              }
            end

          end

          class CatalogVersion

            attr_reader :id, :timestamp, :type, :catalog

            def initialize(incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :catalog], 'CatalogVersion')
              @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
              @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
              @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::Common::V0::Enums::ChangeType) ? x : ::Io::Flow::Common::V0::Enums::ChangeType.apply(x))
              @catalog = (x = opts.delete(:catalog); x.is_a?(::Io::Flow::Catalog::V0::Models::Catalog) ? x : ::Io::Flow::Catalog::V0::Models::Catalog.new(x))
            end

            def to_json
              JSON.dump(to_hash)
            end

            def copy(incoming={})
              CatalogVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
            end

            def to_hash
              {
                :id => id,
                :timestamp => timestamp,
                :type => type.value,
                :catalog => catalog.to_hash
              }
            end

          end

          class Codes

            attr_reader :harmonized

            def initialize(incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              @harmonized = (x = opts.delete(:harmonized); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::Catalog::V0::Models::Harmonized) ? x : ::Io::Flow::Catalog::V0::Models::Harmonized.new(x)))
            end

            def to_json
              JSON.dump(to_hash)
            end

            def copy(incoming={})
              Codes.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
            end

            def to_hash
              {
                :harmonized => harmonized.nil? ? nil : harmonized.to_hash
              }
            end

          end

          class Content

            attr_reader :dimensions, :locale, :price, :title, :brand, :categories, :description, :images, :policies

            def initialize(incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              HttpClient::Preconditions.require_keys(opts, [:dimensions, :locale, :price], 'Content')
              @dimensions = (x = opts.delete(:dimensions); x.is_a?(::Io::Flow::Catalog::V0::Models::Dimensions) ? x : ::Io::Flow::Catalog::V0::Models::Dimensions.new(x))
              @locale = (x = opts.delete(:locale); x.is_a?(::Io::Flow::Catalog::V0::Models::Locale) ? x : ::Io::Flow::Catalog::V0::Models::Locale.new(x))
              @price = (x = opts.delete(:price); x.is_a?(::Io::Flow::Catalog::V0::Models::Price) ? x : ::Io::Flow::Catalog::V0::Models::Price.new(x))
              @title = HttpClient::Preconditions.assert_class('title', (x = opts.delete(:title); x.nil? ? "XXXX" : x), String)
              @brand = (x = opts.delete(:brand); x.nil? ? nil : HttpClient::Preconditions.assert_class('brand', x, String))
              @categories = HttpClient::Preconditions.assert_class('categories', (x = opts.delete(:categories); x.nil? ? [] : x), Array).map { |v| HttpClient::Preconditions.assert_class('categories', v, String) }
              @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
              @images = (x = opts.delete(:images); x.nil? ? nil : HttpClient::Preconditions.assert_class('images', x, Array).map { |v| (x = v; x.is_a?(::Io::Flow::Catalog::V0::Models::Image) ? x : ::Io::Flow::Catalog::V0::Models::Image.new(x)) })
              @policies = (x = opts.delete(:policies); x.nil? ? nil : HttpClient::Preconditions.assert_class('policies', x, Array).map { |v| (x = v; x.is_a?(::Io::Flow::Catalog::V0::Models::Policy) ? x : ::Io::Flow::Catalog::V0::Models::Policy.new(x)) })
            end

            def to_json
              JSON.dump(to_hash)
            end

            def copy(incoming={})
              Content.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
            end

            def to_hash
              {
                :dimensions => dimensions.to_hash,
                :locale => locale.to_hash,
                :price => price.to_hash,
                :title => title,
                :brand => brand,
                :categories => categories,
                :description => description,
                :images => images.nil? ? nil : images.map { |o| o.to_hash },
                :policies => policies.nil? ? nil : policies.map { |o| o.to_hash }
              }
            end

          end

          class Dimension

            attr_reader :units, :value

            def initialize(incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              HttpClient::Preconditions.require_keys(opts, [:units, :value], 'Dimension')
              @units = (x = opts.delete(:units); x.is_a?(::Io::Flow::Common::V0::Enums::UnitOfMeasurement) ? x : ::Io::Flow::Common::V0::Enums::UnitOfMeasurement.apply(x))
              @value = HttpClient::Preconditions.assert_class('value', opts.delete(:value), String)
            end

            def to_json
              JSON.dump(to_hash)
            end

            def copy(incoming={})
              Dimension.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
            end

            def to_hash
              {
                :units => units.value,
                :value => value
              }
            end

          end

          class DimensionSpecification

            attr_reader :depth, :length, :weight, :width

            def initialize(incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              @depth = (x = opts.delete(:depth); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::Catalog::V0::Models::Dimension) ? x : ::Io::Flow::Catalog::V0::Models::Dimension.new(x)))
              @length = (x = opts.delete(:length); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::Catalog::V0::Models::Dimension) ? x : ::Io::Flow::Catalog::V0::Models::Dimension.new(x)))
              @weight = (x = opts.delete(:weight); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::Catalog::V0::Models::Dimension) ? x : ::Io::Flow::Catalog::V0::Models::Dimension.new(x)))
              @width = (x = opts.delete(:width); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::Catalog::V0::Models::Dimension) ? x : ::Io::Flow::Catalog::V0::Models::Dimension.new(x)))
            end

            def to_json
              JSON.dump(to_hash)
            end

            def copy(incoming={})
              DimensionSpecification.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
            end

            def to_hash
              {
                :depth => depth.nil? ? nil : depth.to_hash,
                :length => length.nil? ? nil : length.to_hash,
                :weight => weight.nil? ? nil : weight.to_hash,
                :width => width.nil? ? nil : width.to_hash
              }
            end

          end

          class Dimensions

            attr_reader :physical, :shipping

            def initialize(incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              @physical = (x = opts.delete(:physical); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::Catalog::V0::Models::DimensionSpecification) ? x : ::Io::Flow::Catalog::V0::Models::DimensionSpecification.new(x)))
              @shipping = (x = opts.delete(:shipping); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::Catalog::V0::Models::DimensionSpecification) ? x : ::Io::Flow::Catalog::V0::Models::DimensionSpecification.new(x)))
            end

            def to_json
              JSON.dump(to_hash)
            end

            def copy(incoming={})
              Dimensions.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
            end

            def to_hash
              {
                :physical => physical.nil? ? nil : physical.to_hash,
                :shipping => shipping.nil? ? nil : shipping.to_hash
              }
            end

          end

          class Harmonized

            attr_reader :hs6, :hs10

            def initialize(incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              @hs6 = (x = opts.delete(:hs6); x.nil? ? nil : HttpClient::Preconditions.assert_class('hs6', x, String))
              @hs10 = (x = opts.delete(:hs10); x.nil? ? nil : HttpClient::Preconditions.assert_class('hs10', x, Array).map { |v| (x = v; x.is_a?(::Io::Flow::Catalog::V0::Models::HarmonizedGeo) ? x : ::Io::Flow::Catalog::V0::Models::HarmonizedGeo.new(x)) })
            end

            def to_json
              JSON.dump(to_hash)
            end

            def copy(incoming={})
              Harmonized.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
            end

            def to_hash
              {
                :hs6 => hs6,
                :hs10 => hs10.nil? ? nil : hs10.map { |o| o.to_hash }
              }
            end

          end

          class HarmonizedGeo

            attr_reader :code, :from, :to

            def initialize(incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              @code = (x = opts.delete(:code); x.nil? ? nil : HttpClient::Preconditions.assert_class('code', x, String))
              @from = (x = opts.delete(:from); x.nil? ? nil : HttpClient::Preconditions.assert_class('from', x, String))
              @to = (x = opts.delete(:to); x.nil? ? nil : HttpClient::Preconditions.assert_class('to', x, String))
            end

            def to_json
              JSON.dump(to_hash)
            end

            def copy(incoming={})
              HarmonizedGeo.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
            end

            def to_hash
              {
                :code => code,
                :from => from,
                :to => to
              }
            end

          end

          class Image

            attr_reader :tags, :url

            def initialize(incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              HttpClient::Preconditions.require_keys(opts, [:url], 'Image')
              @tags = HttpClient::Preconditions.assert_class('tags', (x = opts.delete(:tags); x.nil? ? [] : x), Array).map { |v| HttpClient::Preconditions.assert_class('tags', v, String) }
              @url = HttpClient::Preconditions.assert_class('url', opts.delete(:url), String)
            end

            def to_json
              JSON.dump(to_hash)
            end

            def copy(incoming={})
              Image.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
            end

            def to_hash
              {
                :tags => tags,
                :url => url
              }
            end

          end

          class Item

            attr_reader :id, :number, :attributes, :codes, :content, :metadata

            def initialize(incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              HttpClient::Preconditions.require_keys(opts, [:id, :number, :codes, :content, :metadata], 'Item')
              @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
              @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
              @attributes = HttpClient::Preconditions.assert_class('attributes', (x = opts.delete(:attributes); x.nil? ? [] : x), Array).map { |v| (x = v; x.is_a?(::Io::Flow::Catalog::V0::Models::Attribute) ? x : ::Io::Flow::Catalog::V0::Models::Attribute.new(x)) }
              @codes = (x = opts.delete(:codes); x.is_a?(::Io::Flow::Catalog::V0::Models::Codes) ? x : ::Io::Flow::Catalog::V0::Models::Codes.new(x))
              @content = HttpClient::Preconditions.assert_class('content', opts.delete(:content), Array).map { |v| (x = v; x.is_a?(::Io::Flow::Catalog::V0::Models::Content) ? x : ::Io::Flow::Catalog::V0::Models::Content.new(x)) }
              @metadata = HttpClient::Preconditions.assert_class('metadata', opts.delete(:metadata), Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('metadata', d[1], String); h }
            end

            def to_json
              JSON.dump(to_hash)
            end

            def copy(incoming={})
              Item.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
            end

            def to_hash
              {
                :id => id,
                :number => number,
                :attributes => attributes.map { |o| o.to_hash },
                :codes => codes.to_hash,
                :content => content.map { |o| o.to_hash },
                :metadata => metadata
              }
            end

          end

          class ItemCreated < Event

            attr_reader :id

            def initialize(incoming={})
              super(:name => Event::Types::ITEM_CREATED)
              opts = HttpClient::Helper.symbolize_keys(incoming)
              HttpClient::Preconditions.require_keys(opts, [:id], 'ItemCreated')
              @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            end

            def to_json
              JSON.dump(to_hash)
            end

            def copy(incoming={})
              ItemCreated.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
            end

            def subtype_to_hash
              {
                :id => id
              }
            end

          end

          class ItemDeleted < Event

            attr_reader :id

            def initialize(incoming={})
              super(:name => Event::Types::ITEM_DELETED)
              opts = HttpClient::Helper.symbolize_keys(incoming)
              HttpClient::Preconditions.require_keys(opts, [:id], 'ItemDeleted')
              @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            end

            def to_json
              JSON.dump(to_hash)
            end

            def copy(incoming={})
              ItemDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
            end

            def subtype_to_hash
              {
                :id => id
              }
            end

          end

          class ItemForm

            attr_reader :attributes, :codes, :content, :metadata, :number

            def initialize(incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              HttpClient::Preconditions.require_keys(opts, [:codes, :content, :metadata, :number], 'ItemForm')
              @attributes = HttpClient::Preconditions.assert_class('attributes', (x = opts.delete(:attributes); x.nil? ? [] : x), Array).map { |v| (x = v; x.is_a?(::Io::Flow::Catalog::V0::Models::Attribute) ? x : ::Io::Flow::Catalog::V0::Models::Attribute.new(x)) }
              @codes = (x = opts.delete(:codes); x.is_a?(::Io::Flow::Catalog::V0::Models::Codes) ? x : ::Io::Flow::Catalog::V0::Models::Codes.new(x))
              @content = HttpClient::Preconditions.assert_class('content', opts.delete(:content), Array).map { |v| (x = v; x.is_a?(::Io::Flow::Catalog::V0::Models::Content) ? x : ::Io::Flow::Catalog::V0::Models::Content.new(x)) }
              @metadata = HttpClient::Preconditions.assert_class('metadata', opts.delete(:metadata), Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('metadata', d[1], String); h }
              @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            end

            def to_json
              JSON.dump(to_hash)
            end

            def copy(incoming={})
              ItemForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
            end

            def to_hash
              {
                :attributes => attributes.map { |o| o.to_hash },
                :codes => codes.to_hash,
                :content => content.map { |o| o.to_hash },
                :metadata => metadata,
                :number => number
              }
            end

          end

          class ItemUpdated < Event

            attr_reader :id

            def initialize(incoming={})
              super(:name => Event::Types::ITEM_UPDATED)
              opts = HttpClient::Helper.symbolize_keys(incoming)
              HttpClient::Preconditions.require_keys(opts, [:id], 'ItemUpdated')
              @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            end

            def to_json
              JSON.dump(to_hash)
            end

            def copy(incoming={})
              ItemUpdated.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
            end

            def subtype_to_hash
              {
                :id => id
              }
            end

          end

          class ItemVersion

            attr_reader :id, :timestamp, :type, :item

            def initialize(incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :item], 'ItemVersion')
              @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
              @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
              @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::Common::V0::Enums::ChangeType) ? x : ::Io::Flow::Common::V0::Enums::ChangeType.apply(x))
              @item = (x = opts.delete(:item); x.is_a?(::Io::Flow::Catalog::V0::Models::Item) ? x : ::Io::Flow::Catalog::V0::Models::Item.new(x))
            end

            def to_json
              JSON.dump(to_hash)
            end

            def copy(incoming={})
              ItemVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
            end

            def to_hash
              {
                :id => id,
                :timestamp => timestamp,
                :type => type.value,
                :item => item.to_hash
              }
            end

          end

          class Locale

            attr_reader :country, :language

            def initialize(incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              @country = (x = opts.delete(:country); x.nil? ? nil : HttpClient::Preconditions.assert_class('country', x, String))
              @language = (x = opts.delete(:language); x.nil? ? nil : HttpClient::Preconditions.assert_class('language', x, String))
            end

            def to_json
              JSON.dump(to_hash)
            end

            def copy(incoming={})
              Locale.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
            end

            def to_hash
              {
                :country => country,
                :language => language
              }
            end

          end

          class Policy

            attr_reader :id

            def initialize(incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              HttpClient::Preconditions.require_keys(opts, [:id], 'Policy')
              @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            end

            def to_json
              JSON.dump(to_hash)
            end

            def copy(incoming={})
              Policy.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
            end

            def to_hash
              {
                :id => id
              }
            end

          end

          class Price

            attr_reader :current, :msrp

            def initialize(incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              @current = (x = opts.delete(:current); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::Common::V0::Models::Price) ? x : ::Io::Flow::Common::V0::Models::Price.new(x)))
              @msrp = (x = opts.delete(:msrp); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::Common::V0::Models::Price) ? x : ::Io::Flow::Common::V0::Models::Price.new(x)))
            end

            def to_json
              JSON.dump(to_hash)
            end

            def copy(incoming={})
              Price.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
            end

            def to_hash
              {
                :current => current.nil? ? nil : current.to_hash,
                :msrp => msrp.nil? ? nil : msrp.to_hash
              }
            end

          end

          class View

            attr_reader :id, :catalog, :key, :countries, :currency, :query, :settings

            def initialize(incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              HttpClient::Preconditions.require_keys(opts, [:id, :catalog, :key, :countries, :currency, :query, :settings], 'View')
              @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
              @catalog = (x = opts.delete(:catalog); x.is_a?(::Io::Flow::Catalog::V0::Models::Catalog) ? x : ::Io::Flow::Catalog::V0::Models::Catalog.new(x))
              @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
              @countries = HttpClient::Preconditions.assert_class('countries', opts.delete(:countries), Array).map { |v| HttpClient::Preconditions.assert_class('countries', v, String) }
              @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
              @query = HttpClient::Preconditions.assert_class('query', opts.delete(:query), String)
              @settings = (x = opts.delete(:settings); x.is_a?(::Io::Flow::Catalog::V0::Models::ViewSettings) ? x : ::Io::Flow::Catalog::V0::Models::ViewSettings.new(x))
            end

            def to_json
              JSON.dump(to_hash)
            end

            def copy(incoming={})
              View.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
            end

            def to_hash
              {
                :id => id,
                :catalog => catalog.to_hash,
                :key => key,
                :countries => countries,
                :currency => currency,
                :query => query,
                :settings => settings.to_hash
              }
            end

          end

          class ViewForm

            attr_reader :key, :countries, :currency, :query, :settings

            def initialize(incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              HttpClient::Preconditions.require_keys(opts, [:key, :countries, :currency, :query, :settings], 'ViewForm')
              @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
              @countries = HttpClient::Preconditions.assert_class('countries', opts.delete(:countries), Array).map { |v| HttpClient::Preconditions.assert_class('countries', v, String) }
              @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
              @query = HttpClient::Preconditions.assert_class('query', opts.delete(:query), String)
              @settings = (x = opts.delete(:settings); x.is_a?(::Io::Flow::Catalog::V0::Models::ViewSettingsForm) ? x : ::Io::Flow::Catalog::V0::Models::ViewSettingsForm.new(x))
            end

            def to_json
              JSON.dump(to_hash)
            end

            def copy(incoming={})
              ViewForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
            end

            def to_hash
              {
                :key => key,
                :countries => countries,
                :currency => currency,
                :query => query,
                :settings => settings.to_hash
              }
            end

          end

          class ViewItem

            attr_reader :id, :data

            def initialize(incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              HttpClient::Preconditions.require_keys(opts, [:id, :data], 'ViewItem')
              @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
              @data = (x = opts.delete(:data); x.is_a?(::Io::Flow::Catalog::V0::Models::Item) ? x : ::Io::Flow::Catalog::V0::Models::Item.new(x))
            end

            def to_json
              JSON.dump(to_hash)
            end

            def copy(incoming={})
              ViewItem.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
            end

            def to_hash
              {
                :id => id,
                :data => data.to_hash
              }
            end

          end

          class ViewSettings

            attr_reader :update_policy

            def initialize(incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              @update_policy = (x = (x = opts.delete(:update_policy); x.nil? ? "auto" : x); x.is_a?(::Io::Flow::Catalog::V0::Models::UpdatePolicy) ? x : ::Io::Flow::Catalog::V0::Models::UpdatePolicy.apply(x))
            end

            def to_json
              JSON.dump(to_hash)
            end

            def copy(incoming={})
              ViewSettings.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
            end

            def to_hash
              {
                :update_policy => update_policy.value
              }
            end

          end

          class ViewSettingsForm

            attr_reader :update_policy

            def initialize(incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              @update_policy = (x = opts.delete(:update_policy); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::Catalog::V0::Models::UpdatePolicy) ? x : ::Io::Flow::Catalog::V0::Models::UpdatePolicy.apply(x)))
            end

            def to_json
              JSON.dump(to_hash)
            end

            def copy(incoming={})
              ViewSettingsForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
            end

            def to_hash
              {
                :update_policy => update_policy.nil? ? nil : update_policy.value
              }
            end

          end

          class ViewVersion

            attr_reader :id, :timestamp, :type, :view

            def initialize(incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :view], 'ViewVersion')
              @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
              @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
              @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::Common::V0::Enums::ChangeType) ? x : ::Io::Flow::Common::V0::Enums::ChangeType.apply(x))
              @view = (x = opts.delete(:view); x.is_a?(::Io::Flow::Catalog::V0::Models::View) ? x : ::Io::Flow::Catalog::V0::Models::View.new(x))
            end

            def to_json
              JSON.dump(to_hash)
            end

            def copy(incoming={})
              ViewVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
            end

            def to_hash
              {
                :id => id,
                :timestamp => timestamp,
                :type => type.value,
                :view => view.to_hash
              }
            end

          end

        end

        # ===== END OF SERVICE DEFINITION =====
        module HttpClient

          class Request

            def initialize(uri)
              @uri = Preconditions.assert_class('uri', uri, URI)
              @params = nil
              @body = nil
              @auth = nil
              @headers = {}
              @header_keys_lower_case = []
            end

            def with_header(name, value)
              Preconditions.check_not_blank('name', name, "Header name is required")
              Preconditions.check_not_blank('value', value, "Header value is required")
              Preconditions.check_state(!@headers.has_key?(name),
                                        "Duplicate header named[%s]" % name)
              @headers[name] = value
              @header_keys_lower_case << name.downcase
              self
            end

            def with_auth(auth)
              Preconditions.assert_class('auth', auth, HttpClient::Authorization)
              Preconditions.check_state(@auth.nil?, "auth previously set")

              if auth.scheme.name == AuthScheme::BASIC.name
                @auth = auth
              else
                raise "Auth Scheme[#{auth.scheme.name}] not supported"
              end
              self
            end

            def with_query(params)
              Preconditions.assert_class('params', params, Hash)
              Preconditions.check_state(@params.nil?, "Already have query parameters")
              @params = params
              self
            end

            # Wrapper to set Content-Type header to application/json and set
            # the provided json document as the body
            def with_json(json)
              @headers['Content-Type'] ||= 'application/json; charset=UTF-8'
              with_body(json)
            end

            def with_body(body)
              Preconditions.check_not_blank('body', body)
              @body = body
              self
            end

            # Creates a new Net:HTTP client. The client returned should be
            # fully configured to make a request.
            def new_http_client
              client = Net::HTTP.new(@uri.host, @uri.port)
              if @uri.scheme == "https"
                configure_ssl(client)
              end
              client
            end

            # If HTTP is required, this method accepts an HTTP Client and configures SSL
            def configure_ssl(client)
              Preconditions.assert_class('client', client, Net::HTTP)
              client.use_ssl = true
              client.verify_mode = OpenSSL::SSL::VERIFY_PEER
              client.cert_store = OpenSSL::X509::Store.new
              client.cert_store.set_default_paths
            end

            def get(&block)
              do_request(Net::HTTP::Get, &block)
            end

            def delete(&block)
              do_request(Net::HTTP::Delete, &block)
            end

            def options(&block)
              do_request(Net::HTTP::Options, &block)
            end

            def post(&block)
              do_request(Net::HTTP::Post, &block)
            end

            def put(&block)
              do_request(Net::HTTP::Put, &block)
            end

            class PATCH < Net::HTTP::Put
              METHOD = "PATCH"
            end

            def patch(&block)
              do_request(PATCH, &block)
            end

            def do_request(klass)
              Preconditions.assert_class('klass', klass, Class)

              uri = @uri.to_s
              if q = to_query(@params)
                uri += "?%s" % q
              end

              request = klass.send(:new, uri)

              curl = ['curl']
              if klass != Net::HTTP::Get
                curl << "-X%s" % klass.name.split("::").last.upcase
              end

              if @body
                # DEBUG path = "/tmp/rest_client.tmp"
                # DEBUG File.open(path, "w") { |os| os << @body.to_s }
                # DEBUG curl << "-d@%s" % path
                request.body = @body
              end

              if @auth
                curl << "-u \"%s:%s\"" % [@auth.username, @auth.password]
                Preconditions.check_state(!@header_keys_lower_case.include?("authorization"),
                                          "Cannot specify both an Authorization header and an auth instance")
                user_pass = "%s:%s" % [@auth.username, @auth.password]
                encoded = Base64.encode64(user_pass).to_s.split("\n").map(&:strip).join
                request.add_field("Authorization", "Basic %s" % encoded)
              end

              @headers.each { |key, value|
                curl <<  "-H \"%s: %s\"" % [key, value]
                request.add_field(key, value)
              }

              curl << "'%s'" % uri
              # DEBUG puts curl.join(" ")

              raw_response = http_request(request)
              response = raw_response.to_s == "" ? nil : JSON.parse(raw_response)

              if block_given?
                yield response
              else
                response
              end
            end

            private
            def to_query(params={})
              parts = (params || {}).map { |k,v|
                if v.respond_to?(:each)
                  v.map { |el| "%s=%s" % [k, CGI.escape(el.to_s)] }
                else
                  "%s=%s" % [k, CGI.escape(v.to_s)]
                end
              }
              parts.empty? ? nil : parts.join("&")
            end

            def http_request(request)
              response = begin
                           new_http_client.request(request)
                         rescue SocketError => e
                           raise Exception.new("Error accessing uri[#{@uri}]: #{e}")
                         end

              case response
              when Net::HTTPSuccess
                response.body
              else
                body = response.body rescue nil
                raise HttpClient::ServerError.new(response.code.to_i, response.message, :body => body, :uri => @uri.to_s)
              end
            end
          end

          class ServerError < StandardError

            attr_reader :code, :details, :body, :uri

            def initialize(code, details, incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              @code = HttpClient::Preconditions.assert_class('code', code, Integer)
              @details = HttpClient::Preconditions.assert_class('details', details, String)
              @body = HttpClient::Preconditions.assert_class_or_nil('body', opts.delete(:body), String)
              @uri = HttpClient::Preconditions.assert_class_or_nil('uri', opts.delete(:uri), String)
              HttpClient::Preconditions.assert_empty_opts(opts)
              super(self.message)
            end

            def message
              m = "%s %s" % [@code, @details]
              if @body
                m << ": %s" % @body
              end
              m
            end

            def body_json
              JSON.parse(@body)
            end

          end

          class PreconditionException < Exception

            attr_reader :message

            def initialize(message)
              super(message)
              @message = message
            end

          end

          module Preconditions

            def Preconditions.check_argument(expression, error_message=nil)
              if !expression
                raise PreconditionException.new(error_message || "check_argument failed")
              end
              nil
            end

            def Preconditions.check_state(expression, error_message=nil)
              if !expression
                raise PreconditionException.new(error_message || "check_state failed")
              end
              nil
            end

            def Preconditions.check_not_nil(field_name, reference, error_message=nil)
              if reference.nil?
                raise PreconditionException.new(error_message || "argument for %s cannot be nil" % field_name)
              end
              reference
            end

            def Preconditions.check_not_blank(field_name, reference, error_message=nil)
              if reference.to_s.strip == ""
                raise PreconditionException.new(error_message || "argument for %s cannot be blank" % field_name)
              end
              reference
            end

            # Throws an error if opts is not empty. Useful when parsing
            # arguments to a function
            def Preconditions.assert_empty_opts(opts)
              if !opts.empty?
                raise PreconditionException.new("Invalid opts: #{opts.keys.inspect}\n#{opts.inspect}")
              end
            end

            # Requires that the provided hash has the specified keys.
            # @param fields A list of symbols
            def Preconditions.require_keys(hash, fields, error_prefix=nil)
              missing = fields.select { |f| !hash.has_key?(f) }
              if !missing.empty?
                msg = "Missing required fields: " + missing.join(", ")
                raise PreconditionException.new(error_prefix.empty? ? msg : "#{error_prefix}: #{msg}")
              end
            end

            # Asserts that value is not nill and is_?(klass). Returns
            # value. Common use is
            #
            # amount = Preconditions.assert_class('amount', amount, BigDecimal)
            def Preconditions.assert_class(field_name, value, klass)
              Preconditions.check_not_nil('field_name', field_name)
              Preconditions.check_not_nil('klass', klass)
              Preconditions.check_not_nil('value', value, "Value for %s cannot be nil. Expected an instance of class %s" % [field_name, klass.name])
              Preconditions.check_state(value.is_a?(klass),
                                        "Value for #{field_name} is of type[#{value.class}] - class[#{klass}] is required. value[#{value.inspect.to_s}]")
              value
            end

            def Preconditions.assert_class_or_nil(field_name, value, klass)
              if !value.nil?
                Preconditions.assert_class(field_name, value, klass)
              end
            end

            def Preconditions.assert_boolean(field_name, value)
              Preconditions.check_not_nil('field_name', field_name)
              Preconditions.check_not_nil('value', value, "Value for %s cannot be nil. Expected an instance of TrueClass or FalseClass" % field_name)
              Preconditions.check_state(value.is_a?(TrueClass) || value.is_a?(FalseClass),
                                        "Value for #{field_name} is of type[#{value.class}] - class[TrueClass or FalseClass] is required. value[#{value.inspect.to_s}]")
              value
            end

            def Preconditions.assert_boolean_or_nil(field_name, value)
              if !value.nil?
                Preconditions.assert_boolean(field_name, value)
              end
            end

            def Preconditions.assert_collection_of_class(field_name, values, klass)
              Preconditions.assert_class(field_name, values, Array)
              values.each { |v| Preconditions.assert_class(field_name, v, klass) }
            end

            def Preconditions.assert_hash_of_class(field_name, hash, klass)
              Preconditions.assert_class(field_name, hash, Hash)
              values.each { |k, v| Preconditions.assert_class(field_name, v, klass) }
            end

          end

          class AuthScheme

            attr_reader :name

            def initialize(name)
              @name = HttpClient::Preconditions.check_not_blank('name', name)
            end

            BASIC = AuthScheme.new("basic") unless defined?(BASIC)

          end

          class Authorization

            attr_reader :scheme, :username, :password

            def initialize(scheme, username, opts={})
              @scheme = HttpClient::Preconditions.assert_class('schema', scheme, AuthScheme)
              @username = HttpClient::Preconditions.check_not_blank('username', username, "username is required")
              @password = HttpClient::Preconditions.assert_class_or_nil('password', opts.delete(:password), String)
              HttpClient::Preconditions.assert_empty_opts(opts)
            end

            def Authorization.basic(username, password=nil)
              Authorization.new(AuthScheme::BASIC, username, :password => password)
            end

          end

          module Helper

            def Helper.symbolize_keys(hash)
              Preconditions.assert_class('hash', hash, Hash)
              new_hash = {}
              hash.each { |k, v|
                new_hash[k.to_sym] = v
              }
              new_hash
            end

            def Helper.to_big_decimal(value)
              value ? BigDecimal.new(value.to_s) : nil
            end

            def Helper.to_object(value)
              value ? JSON.parse(value) : nil
            end

            def Helper.to_uuid(value)
              Preconditions.check_state(value.nil? || value.match(/^\w\w\w\w\w\w\w\w\-\w\w\w\w\-\w\w\w\w\-\w\w\w\w\-\w\w\w\w\w\w\w\w\w\w\w\w$/),
                                        "Invalid guid[%s]" % value)
              value
            end

            def Helper.to_date_iso8601(value)
              if value.is_a?(Date)
                value
              elsif value
                Date.parse(value.to_s)
              else
                nil
              end
            end

            def Helper.to_date_time_iso8601(value)
              if value.is_a?(DateTime)
                value
              elsif value
                DateTime.parse(value.to_s)
              else
                nil
              end
            end

            def Helper.date_iso8601_to_string(value)
              value.nil? ? nil : value.strftime('%Y-%m-%d')
            end

            def Helper.date_time_iso8601_to_string(value)
              value.nil? ? nil : value.strftime('%Y-%m-%dT%H:%M:%S%z')
            end

            TRUE_STRINGS = ['t', 'true', 'y', 'yes', 'on', '1', 'trueclass'] unless defined?(TRUE_STRINGS)
            FALSE_STRINGS = ['f', 'false', 'n', 'no', 'off', '0', 'falseclass'] unless defined?(FALSE_STRINGS)

            def Helper.to_boolean(field_name, value)
              string = value.to_s.strip.downcase
              if TRUE_STRINGS.include?(string)
                true
              elsif FALSE_STRINGS.include?(string)
                false
              elsif string != ""
                raise PreconditionException.new("Unsupported boolean value[#{string}]. For true, must be one of: #{TRUE_STRINGS.inspect}. For false, must be one of: #{FALSE_STRINGS.inspect}")
              else
                nil
              end
            end

          end

        end
      end
    end
  end
end